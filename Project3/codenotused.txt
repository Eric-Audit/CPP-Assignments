template <class T>
class LinkedList
{
	protected:
		// Declare a class for the list node
			struct ListNode
			{
			T value;
			ListNode *next;
			ListNode(T value1, ListNode *next1 = NULL)
				{
				value = value1;
				next = next1;
				}
			};
		ListNode *head; // List head pointer
		public:
			LinkedList() { head = NULL; } // Constructor
			LinkedList(const LinkedList& original);
			~LinkedList(); // Destructor
			void displayList() const;
			void add(T value);
			void reverse();
			};
template <class T>
void LinkedList<T>::add(T value)
{
	if (head == NULL)
		head = new ListNode(value);
	else
		{
		// The list is not empty
			// Use nodePtr to traverse the list
			ListNode *nodePtr = head;
		while (nodePtr->next != NULL)
			nodePtr = nodePtr->next;
			// nodePtr->next is NULL so nodePtr points to the last node
			// Create a new node and put it after the last node
			nodePtr->next = new ListNode(value);
		}
}
template <class T>
void LinkedList<T>::displayList() const
{
	ListNode *nodePtr = head; // Start at head of list
	while (nodePtr)
		{
		// Print the value in the current node
			cout << nodePtr->value << " ";
		// Move on to the next node
			nodePtr = nodePtr->next;
		}
	}
template <class T>
void LinkedList<T>::reverse()
{
	ListNode *ptr = head;
	ListNode *b;
	reverse(ptr, ptr->next, b);

}
template <class T>
LinkedList<T>::~LinkedList()
{
	ListNode *nodePtr = head; // Start at head of list
	while (nodePtr != NULL)
		{
		// garbage keeps track of node to be deleted
			ListNode *garbage = nodePtr;
		// Move on to the next node, if any
			nodePtr = nodePtr->next;
		// Delete the "garbage" node
			delete garbage;
		}
}
template <class T>
LinkedList<T>::LinkedList(const LinkedList& original)
{
	head = copyList(original.head);
}